---
layout: post
title: 코딩테스트 8주차_피로도
date: 2025-10-04 16:38:00 +0300
description: "" # Add post description (optional)
img: book_pic1.jpg # Add image post (optional)
fig-caption: # Add figcaption (optional)
tags: [코딩테스트] # add tag
---

## 접근 전략
개념을 우선 이해하고, 수도코드를 짜기 시작했다.  
방문 여부 배열을 만들어 방문 여부를 다시 `Y`로 바꾸어 놓는 로직이 중요함.  
재귀 함수 호출을 통해 가능한 경로를 탐색하고, `result` 값을 갱신한다.  

## 수도 코드

### (1) 모든 조합의 경우 구하기
```java
class Solution {
	
값계산() {

for문 3번 돌아야함 0,1,2(Dungeons length만큼)
[0번째]
if 0 -> 0방문한 적 없고, 80 >= [0][0](80) 같음
	0번 방문처리
	backtrack(80 - [0][1](20), 0+1)
		
		[1번째]
		if 1-> 방문 X, 60  > 50 :
		1번 방문처리
			backtrack(60-[1][1]40, 1+1)
			if 2-> 방문 X, 20 < 30 으로 타지 않음
		answer = Math.max(0,1+1) = 2
		1번 방문처리 취소
		
		[2번째]
		if 2-> 방문 X, 60>30 :
		2번 방문처리 
			backtrack(50, 2+1)
			if 1 -> 방문 X, 50 >= 50:
			1번 방문처리
			length(3)만큼 돌았으니 return 
			1번 방문처리 취소
		answer = Math.max(2,3) = 3
		2번 방문처리 취소

	0번 방문처리 취소 	
}

public int solution(int k, int[[][] dungeons){
	값 초기화;	
	던전 방문여부 저장할 배열 생성;
	갑계산 메소드 호출;
return 값;
}
}

```
## GPT가 짜준 수도 코드
```java
backtrack(k=80, cnt=0) ─ 루트
  ├─ i=0 선택 (80≥80) → visited[0]=T, backtrack(k=60, cnt=1)
  │    ├─ i=1 선택 (60≥50) → visited[1]=T, backtrack(k=20, cnt=2)
  │    │    ├─ i=2 시도: 20≥30? → 실패(재귀 진입 X)
  │    │    └─ for 종료 → 리턴(이 프레임 최대 2)
  │    ├─ (되돌림) visited[1]=F  // 이 시점 k는 60으로 복원됨
  │    ├─ i=2 선택 (60≥30) → visited[2]=T, backtrack(k=50, cnt=2)
  │    │    ├─ i=1 선택 (50≥50) → visited[1]=T, backtrack(k=10, cnt=3)
  │    │    │    └─ 더 이상 진행 불가 → 리턴(이 브랜치 최대 3)
  │    │    └─ (되돌림) visited[1]=F → 리턴
  │    └─ (되돌림) visited[2]=F → 리턴
  └─ (되돌림) visited[0]=F
```
---

## 코테합 책 - 저자님 소스 인용
- *인용: 코딩 테스트 합격자 되기 - 박경록*  
- 링크: https://github.com/minkyungchu1014/java-codingtest-min-template/pull/1/files

---

## 어려웠던 점
1. 수도코드를 작성하는 과정이 깔끔하지 않았다.  
   → 더 많은 연습이 필요하다고 느꼈다.  


---

## 새롭게 알게된 점
1. **백트래킹 = DFS인가? → 그렇지 않다.**  
   하지만 **백트래킹은 DFS를 기반으로 동작하는 탐색 기법**이다.  

   - **DFS**는 탐색 방법: 선택지를 끝까지 파고든 뒤, 다시 되돌아오는 방식 (완전 탐색).  
   - **백트래킹**은 탐색 최적화 기법: DFS의 틀 위에서 **불필요한 가지를 잘라내는(Pruning)** 조건을 추가한 방식.
